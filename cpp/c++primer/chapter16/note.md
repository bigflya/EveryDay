## chapter16 模板与泛型编程
(https://www.informit.com/store/c-plus-plus-primer-9780321714114)[]
### 16.1定义模板

template <typename T>          其中typename也可以换成class

> 在模板的定义中，模板参数列表不能为空。


> template <typename T,U> 这种写法是错误的，必须要在U之前也加上typename


> 引用传参的好处是，即便某些数据不允许拷贝也可以通过引用调用。第二用引用传递可以避免内存空间的浪费。


非类型参数。

模板程序应该尽量减少对实参类型的要求。



> 实例化

给定模板，会根据传递进来的参数来，匹配一个对应的类型，这个过程叫实例化。


> 类模板和函数模板?

函数模板就是可以用来实例化特定函数的模板，实现某一种特定类型函数的蓝图。

类模板就是可以实现特定类型类的模板，也叫实现特定类的蓝图。




> 实例化就是将类中的模板参数  赋予特定类型







什么是双目运算符 ， 为什么后置++ 会有一个 int参数？ 答：这个int在这里作为占位参数，用来区分前置递增和后置递增





返回的是类的对象用引用会更好一点。


> 当我们希望通知编译器一个名字表示类型时，可以使用typename关键字 ，而且不能用class 代替typename

T::size_t a;
可以改成 typename T::size_t a;

> 默认模板实参

如果不给出 模板参数的类型 默认是int


> 模板参数与作用域

目标那参数遵循普通的作用域规则。一个模板参数名的可用范围是在其声明之后，至模板声明或定义结束之前。 模板参数会隐藏外层作用域中声明的相同名字。所以下面做法是对的
typedef char Ctype;
template < typename Ctype> Ctype f5(Ctype a);




> 向 unique_ptr 传递删除器

> 类模板的成员模板

此时需要在类的外面 写上类的模板和乐模板中的成员模板

> 如何实例化类模板和类中的成员模板？

必须同时提供类和成员模板的所有实参

> 控制实例化


加上extern，将实例化声明和实例化定义分开

extern template declaration;//实例化声明
template declaration;//实例化定义

当编译器遇到extern模板声明时，它不会在本文件中生成实例化代码。从而避免编译链接过程中产生冗余代码。


函数声明不会导致实例化
引用不会导致实例化
定义指针不会导致实例化

> 实例化就是创建一个具体的类对象

> 效率优化

通过在编译时绑定删除器，unique_ptr避免了间接调用删除器的运行时开销。通过在运行时绑定删除器，shared_ptr使用户重载删除器更为方便。

### 16.2模板实参推断

函数名 或者数组名 本身就是一个指针，指向函数或者数组的首地址



> const回顾

顶层const可以被忽略
顶层const表示指针本身是常量，即该指针不能被修改为指向其他地址，但是该指针所指向的内容是可以被修改的；
底层const表示指针所指对象为常量，即该指针所指向的内容不能被修改，但是该指针本身是可以被修改的，可以指向其他地址；
声明类const都是底层const，因为类成员函数不能返回一个顶层const指针；
顶层const的拷贝是不受限制的，但是底层const需要相同的const类型或者可以从非常量拷贝给常量。

> 如果采用引用的方式调用数组则数组不会被转化为指针。
如果参数类型不是模板参数则对参数进行正常的转换。通常内置类型都是可以相互转换的
> 将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有（顶层）const转换及数组或函数到指针的转换 这两种。

const int *p2 =& c1;//底层const  ,在模板中不能被忽略，只有顶层const可以
const string s2("bigfly");//顶层const


> 指定显式模板实参，有时候编译器无法推断出模板参数类型，需要显式指定

template < template T1,template T2,template T3>
T1 sum(T2 ,T3);//此时模板在实例化的时候是无法推出返回值T1的类型，需要显式指定返回类型T1

```c++

//T1是显式指定的，T2,T3是从实参类型推断出来的
auto val3=sum<long long>(i,lng);//指定返回值是 long long 类型，这里正在实例化一个函数

//模板类型参数匹配是从左侧匹配的 <long long>  中先匹配template < template T1,template T2,template T3>中的template T1，若要指定 其余参数加在后面就行

//经验：  把需要指明的模板参数写在靠左的位置，自动推断的靠右



```

> 正常类型转换应用于显式指定的实参

```c++

template < template T>
int compare(const T &v1,const T &v2){

    //function operator
}

long lng；
compare(lng,1024);//错误，模板参数不匹配，没有指定模板的参数类型，会根据传入的实参推断，但此时传入两个实参的类型是不同的，而模板要求传入的参数类型要一致。 这里相当于实例化的同时在传参
compare<long>(lng,1024);//正确：实例化compare（long,long）
compare<int>(lng,1024);//正确：指定了模板的参数类型，实例化compare（int,int）,当函数模板实例化后，实参传递给函数模板参数列表的时候是允许类型转换的。
```


> shell界面  执行 cppman max  可以查询max函数的使用方法

```c++

auto m = max(1,2.0);//错误


auto m = max<double>(1,2.0);//正确


```
> 什么时候会用到显式模板实参？

当模板无法自动推断出模板的所有实参的是时候



> 尾置返回类型与类型转换


对于传递的参数的类型。我们几乎一无所知。我们唯一可以使用的操作是迭代器操作，而所有迭代器操作都不会生成元素，只能生成元素的引用。
当一个对象被用作幼稚的时候，用的是对象的值(内容),当对象被用作左值的时候，用的是对象的身份(在内存中的位置)

> 函数参数与其他任何变量一样，都是左值表达式。

即便有时候形参是右值，或者右值引用 ，其传递给函数体内部某个变量，都是作为左值的


### 16.3重载与模板

函数之间构成重载，主要看参数的个数和参数的类型是否相同
模板重载也是类似的

> 多个可行模板的情况。
有多个重载模板对一个调用提供同样好的匹配时，应选择最特例化的版本。
当都提供精确的匹配时，一个非模板函数比一个模板函数有更高的匹配度。



### 16.4可变参数模板
```c++

template <typename T,typename...Args>
void foo(const T &t,const Args...args)
{
    cout<<sizeof...(Args)<<endl;//返回类型参数的数目
    cout<<sizeof...(args)<<endl;//返回函数参数的数目
}
```

没有什么技术 ，使用时查阅相关个格式即可


> 编写可变参数函数模板

一般来说可变参数函数模板都是递归的，

递归函数要考虑的重点就是递归结束的条件


> 包扩展

> emplace_back是C++11标准中引入的一种新特性，它用于在容器的尾部直接创建元素，而不是像push_back()方法那样需要先构造一个临时对象，然后将临时对象的拷贝构造函数拷贝或移动到容器最后面。使用emplace_back()可以省去拷贝或移动元素的过程，提高了效率。


> 可变参数函数通常将它们的参数转发给其他函数。


### 16.5模板特例化

不使用模板，对某一种情况进行特例化，编写特例化函数。特例化就是在实例化
特例化的格式  template<>


> 特例化的本质是实例化的一个模板，而非重载它。因此，特例化不影响函数匹配。


> 特例化本身也是一个模板，它和重载的区别是，重载会增加候选函数的个数，但特例化本身还是模板，只有当某个模板匹配上时，才会有可能根据实参为其进行特例化匹配。