## chapter15 面向对象程序设计

### 15.1 OPP:概述
cd /home/bigfly/Desktop/EveryDay/cpp/c++primer/chapter15
面向对象程序设计的核心思想：**数据抽象**、**继承**和**动态绑定**。

- **数据抽象**： c++类的概念，描述某一个对象的成员变量，以及操作某个对象的成员函数封装在一起。通过数据抽象可以将类的接口和实现分离。
- **继承**：通过继承联系在一起的类构成一种层次关系。 基类(根类)  、派生类。 基类负责在所有层次关系中共有的成员，而派生类定义各自特有的成员。
- **动态绑定**：通过动态绑定，可以使得同一段代码既适用于基类 也适用于派生类。


### 15.2基类和派生类


**虚函数的概念:** 基类有这个函数 ，派生类也有这个函数，但基类和派生类函数的功能执行起来的策略是有区别的。

> 派生类必须通过派生类列表来指出它是从哪些基类继承而来的,派生类列表由冒号后紧跟基类列表 组成。如下代码所示：

```c++
class Bulk_quote : public Quote {
public:
    double net_price(std::size_t) const override;
};
```


> 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。

> 为什么构造函数不能是虚函数？ 为什么静态函数不能是虚函数？

因为虚函数的主要目的是实现动态多态性，也就是在运行时根据对象的实际类型调用相应的函数。而构造函数是在对象创建时调用的，这个时间是静态的，不是动态的。

静态函数不能是虚函数，因为静态函数是属于它所在的文件的，而虚函数是属于类的，属于类的成员函数。静态函数不能被类的外部访问，而虚函数可以在类的外部被访问。此外，静态函数是只被调用一次的，而虚函数可以在子类中被重写多次，这些都不符合静态函数的特性和用途。

> 派生类可以访问基类里面的公有成员，但不能访问私有成员。但是有时候我们希望派生类可以访问，但是其他类不能访问，此时就可以通过 protected 访问运算符说明这样的成员

> 大多数情况下类都只继承自一个类，这种形式的继承被称作“单继承”

> 派生类经常覆盖它继承的虚函数。 派生类可以在它覆盖的函数前面写上 virtual （不是必须的），但是在基类中对应的函数前面必须写上virtual

> 我们能把派生类的对象当成基类来使用，而且我们也能将基类的指针或引用绑定到派生类对象中的基类部分。

> 派生类对象的基类部分与派生类对象自己的数据成员都是在构造函数的初始化阶段执行初始化操作的。

> 派生类的作用域是嵌套在基类的作用域之内的。




> 如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。



> 成员函数访问的几种方法：成员函数要么通过作用域的方式直接使用，要么通过类的对象访问。**this指针是当前正在调用成员函数的类的对象。**



> 防止继承的发生： 加上关键字 final

### 15.3虚函数

> 动态绑定只有当我们通过指针或引用调用虚函数时才会发生。也只有在这种情况下对象的动态类型才有可能与静态类型不同。



> 派生类中的虚函数
当在派生类中覆盖了某个虚函数时，可以再一次使用virtual 关键字指出该函数的性质。并非必须这样做，只是为了方便代码阅读

> final 和override

c++11提供新的特性，其中override 关键字是用来覆盖掉基类中的重名虚函数。
这么做的好处是使得程序员的意图更加清晰的同时让编译器可以为我们发现一些错误，即在编译阶段报错而不是运行阶段报错。
final是为了不让某个类产生派生类 ，即不希望此类被继承

> 回避虚函数机制

在某些情况下我们希望对虚函数的调用不要进行绑定，而是强迫其执行虚函数的某个版本。

> 什么时候需要回避虚函数的默认机制

如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时调用将被解析为对派生类版本自身的调用，从而导致无限递归。

> 纯虚函数，只定义不实现。

> 纯虚函数不能创建对象

> 抽象基类

> 派生类构造函数只能初始化直接基类

简单说，只能调用其继承的基类（直接基类）中的构造函数，而不能调用基类的基类（间接基类）中的构造函数。


### 15.5 访问控制与继承

protected 关键字和 private 关键字类似 ，不能被外部所访问， protected来声明那些它希望与派生类分享但是不想被其他公共访问使用的成员。


派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权。 我个人的理解就是谁中的函数只能访问谁中的成员（包括继承自基类的那一部分），而不能直接访问基类中的受保护的成员（如果此处成立的话，相当于基类中的protected关键字无效，即受保护的成员泄露）。



友元函数可以访问类里面的私有成员

> 派生类向基类转换的可访问性

1. 只有当D共有地继承B时，用户代码才能使用派生类向基类的转换；如果D继承B的方式是受保护的或者私有的，则用户代码不能使用该转换。
2. 不论D以什么方式继承B，D的成员函数和友元都能使用派生类向基类的转换；派生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的。
3. 如果D继承B的方式是公有或者受保护的，则D的派生类的成员和友元可以使用D向B的类型转换；反之，如果D继承B的方式是私有的，则不能使用。


> 友元与继承

1. 友元关系是不能传递的，要记住这一点。

2. 当一个类将另一个类声明为友元时，这种友元关系只对作出声明的类有效。对于原来那个类来说，其友元的基类或或者派生类不具有特殊的访问能力。


派生类只能为那些它可以访问的名字提供using声明。


> class与struct 创建的类有何不同？

class默认的成员类型都是私有的，struct默认的类型都是共有的。

一个私有派生的类最好显式地将private声明出来，而不要仅仅依赖于默认设置。显式声明的好处是可以令私有继承关系清晰明了，不至于产生误会。



### 15.6继承中的类作用域
分清楚静态类型 和动态类型的区别
当基类的类型指向派生类时候，会出现静态类型和动态类型的分离。
能使用哪些成员是由静态类型决定的。

通过作用域运算符来使用隐藏的成员。

虚函数与定义域：
基类与派生类中虚函数的参数列表应是相同的

覆盖重载的函数：
在派生类中使用 using base::fcn;//覆盖掉部分的做法如下


### 15.7构造函数与拷贝控制

和其他类一样，位于继承体系中的类也需要控制当其对象执行一系列操作时发生什么样的行为，这些操作包括创建、拷贝、移动、赋值和销毁。

基类通常要有一个虚析构函数。

> 如果基类的析构函数不是虚函数，则delete一个只想派生类对象的基类指针将产生未定义的行为。

虚析构函数将阻止合成移动操作

析构函数主要的作用是清除类里面定义的数据成员。
如果有指针类型的成员就需要自定义析构函数，完成对指针所指向内存空间的清除。


合成的Bulk_quote默认构造函数运行Disc_quote的默认构造函数，后者又运行Quote的默认构造函数。

Quote的构造函数完成后，继续执行Disc_quote的构造函数，Disc_quote的构造函数完成后，继续执行Bulk_quote的构造m函数，但是它什么具体的工作也不做。


>在C++中，被删除的函数是指那些在类中声明但不允许被调用的函数。被删除的函数通常用 = delete 来进行声明。被删除的函数主要有以下作用：

防止误调用：当我们不小心调用了一个被删除的函数时，编译器会报错，这样可以避免因误调用而引起的程序错误。
明确类接口：通过删除不需要的函数，可以让类接口更加明确，让别人更容易理解这个类是如何使用的。
确保资源的正确释放：在一些情况下，类可能会持有某些资源（如动态分配的内存），当这些资源不再需要时，我们需要正确地释放它们。通过删除不再需要的函数，可以确保资源的正确释放，避免内存泄漏等问题。

>定义虚析构函数的主要目的是为了在派生类对象被删除时正确地释放资源。当一个指向派生类对象的基类指针被删除时，如果没有虚析构函数，只有基类的析构函数会被调用，派生类的资源将不会被正确释放。
如果基类定义了虚析构函数，当通过基类指针删除一个派生类对象时，派生类的析构函数也会被正确调用，从而确保派生类中的资源被正确释放。这是因为虚析构函数使用了动态绑定机制，能够在运行时根据对象的实际类型确定要调用的析构函数。

> 当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象

派生类析构函数只负责销毁由派生那自己分配的资源。派生类的析构函数会自动调用基类的析构函数。
对象销毁的顺序正好与其创建的顺序相反：派生类析构函数首先执行，然后是基类的析构函数，以此类推，沿着继承体系的反方向直至最后。


> 在构造函数和析构函数中调用虚函数

如我们所知，派生类对象的基类部分将首先被构建。当执行基类的构造函数时，该对象的派生类部分是未被初始化的状态。类似的，销毁派生类对象的次序正好相反，因此当执行基类的析构函数时，派生类部分已经被销毁掉了。由此可知，当我们执行上述基类成员的时候，该对象处于未完成的状态。
为了能正确的处理这种未完成的状态，编译器认为对象的类型在构造或析构的过程中仿佛发生了改变一样。

 如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。


假如说用派生类创建一个对象，而某个派生类中的成员有一个同名的虚函数（与基类中的虚函数同名），那么在构造的时候我们遵循的是先构造基类、然后构造派生类，然而如果在基类的构造函数中我们调用了同名虚函数，那么应该执行的是基类中的虚函数而不是派生类中的同名虚函数，因为我们在用派生类创建对象的时候是先执行基类中的构造函数，构造基类的时候我们调用同名虚函数，此时虚函数只能调用基类中的虚函数而不能调用派生类中的虚函数因为派生类此刻还没有被构造，所以派生类中的虚函数是无法被执行的。


### 15.8容器与继承

当派生类对象被赋值给基类对象时，其中的派生类部分将被切掉，因此容器和存在继承关系的类型无法兼容。

如果想要在容器中存放具有继承关系的对象时，可以在容器中存放指针而非对象。


### 15.9 文本查询程序

。。没有新的知识点只是练习