##chapter15 面向对象程序设计

### 15.1 OPP:概述
cd /home/bigfly/Desktop/EveryDay/cpp/c++primer/chapter15
面向对象程序设计的核心思想：**数据抽象**、**继承**和**动态绑定**。

- **数据抽象**： c++类的概念，描述某一个对象的成员变量，以及操作某个对象的成员函数封装在一起。通过数据抽象可以将类的接口和实现分离。
- **继承**：通过继承联系在一起的类构成一种层次关系。 基类(根类)  、派生类。 基类负责在所有层次关系中共有的成员，而派生类定义各自特有的成员。
- **动态绑定**：通过动态绑定，可以使得同一段代码既适用于基类 也适用于派生类。


### 15.2基类和派生类


**虚函数的概念:** 基类有这个函数 ，派生类也有这个函数，但基类和派生类函数的功能执行起来的策略是有区别的。

> 派生类必须通过派生类列表来指出它是从哪些基类继承而来的,派生类列表由冒号后紧跟基类列表 组成。如下代码所示：

```c++
class Bulk_quote : public Quote {
public:
    double net_price(std::size_t) const override;
};
```


> 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。

> 为什么构造函数不能是虚函数？ 为什么静态函数不能是虚函数？

因为虚函数的主要目的是实现动态多态性，也就是在运行时根据对象的实际类型调用相应的函数。而构造函数是在对象创建时调用的，这个时间是静态的，不是动态的。

静态函数不能是虚函数，因为静态函数是属于它所在的文件的，而虚函数是属于类的，属于类的成员函数。静态函数不能被类的外部访问，而虚函数可以在类的外部被访问。此外，静态函数是只被调用一次的，而虚函数可以在子类中被重写多次，这些都不符合静态函数的特性和用途。

> 派生类可以访问基类里面的公有成员，但不能访问私有成员。但是有时候我们希望派生类可以访问，但是其他类不能访问，此时就可以通过 protected 访问运算符说明这样的成员

> 大多数情况下类都只继承自一个类，这种形式的继承被称作“单继承”

> 派生类经常覆盖它继承的虚函数。 派生类可以在它覆盖的函数前面写上 virtual （不是必须的），但是在基类中对应的函数前面必须写上virtual

> 我们能把派生类的对象当成基类来使用，而且我们也能将基类的指针或引用绑定到派生类对象中的基类部分。

> 派生类对象的基类部分与派生类对象自己的数据成员都是在构造函数的初始化阶段执行初始化操作的。

> 派生类的作用域是嵌套在基类的作用域之内的。




> 如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。



> 成员函数访问的几种方法：成员函数要么通过作用域的方式直接使用，要么通过类的对象访问。**this指针是当前正在调用成员函数的类的对象。**



> 防止继承的发生： 加上关键字 final
