## Note_14
cd /home/bigfly/Desktop/EveryDay/cpp/c++primer/chapter14

重载的运算符是具有特殊名字的函数

#### 不能重载的运算符
1. “.”成员访问运算符
2. “.*”成员指针访问运算符
3. “::”域运算符
4. “sizeof”长度运算符
5. “? : ”条件运算符

#### 不能使用友元函数重载的运算符
1. “=”
2. “->”
3. “[]”
4. “()”

> 一元运算符和二元运算符的区别在于它们的操作数不同。

一元运算符只需要一个操作数，而二元运算符需要两个操作数。

> 使用重载运算符本质上是一次函数的调用，所以这些关于运算对象求职顺序的规则无法应用到重载的运算符上。


> 当运算符两侧的类型不一样时，用到的是左侧运算对象的重载函数。


> 将运算符定义为成员函数或者普通的非成员函数的准则：

- 赋值(-)、下标([])、调用(())和成员访问箭头(->)运算符必须是成员。
- 符合赋值运算符一般来说是成员、但并非必须、这一点与赋值运算符略有不同。
- 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员。
- 具有对称性的运算符可以转换为任意一端的运算对象、例如算数、相等性、关系和位运算符等。因此他们通常应该是普通的非成员函数。

**一般来说即便是非成员函数也要将其定义为友元函数，这样可以方便访问类的对象。**


> 如果类定义了算数运算符，通常也会定义一个对应的复合赋值运算符。

> 如果类同时定义了算数运算符和相关的复合运算符，则通常情况下应该使用复合赋值来实现算数运算符。

> 相等运算符和不相等运算符中的一个应该把工作委托给另外一个，这意味着其中一个运算符应该负责实际比较对象的工作，而另外一个运算符则只是调用那个真正工作的运算符。


> 赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这样做。这两类运算符都应该返回左侧运算对象的引用。

> void func() const { xxx; return x;}
上面的const 是指 返回值只能读 ，不能对其进行赋值。

> 如果一个类包含下标运算符，则它通常会定义两个版本，一个返回普通引用（这意味着可以对其进行修改），另一个是类的常量成员并返回的是常量引用。如下所示:

```c++
class StrBlob
{
        public:
                string &operator[](size_t n){return (*data)[n];}//下标运算符必须是成员函数, 访问指针data中的内容，对其解引用  ，然后用下标n来确[>
                const string &operator[](size_t n)const {return (*data)[n];}

};

```

### 递增和递减运算符

> 前置运算符应该返回递增或递减后对象的**引用**

> 后置版本返回值

### 成员访问运算符

 > 解引用 *  返回类型是一个& string 
 
 > 而-> 返回类型是 * string 类型的

 > 一般来说 -> 箭头运算符必须是类的成员。解引用运算符通常也是类的成员，尽管并非必须如此。
  
 > 为什么箭头运算符必须是类的成员？

 因为在->运算符重载函数中会通过类的this地址调用类中的 解引用重载函数。
> 对于形如point->mem 的表达式来说，无非有以下两种含义：
1. point是指向某一个类的对象的指针。（**直到此刻我才真正明白什么是对象**），通过对这个指针使用 箭头运算符 来实现成员函数的访问。
```c++
#include <iostream>
using namespace std;

class A
{
	public:
		void mem()
		{
			cout<< "mem in class A!"<< endl;
		}

};


int main(void)
{
	A *point  = new A;
	point->mem();//point是指向某一个类的对象的指针，通过对这个指针使用 箭头运算符 来实现成员函数的访问。
	(*point).mem();//上面的等价写法
	
	return 0;
}
```

2. point是某个类的对象，只不过此时它在调用类中的operator->重载函数。

```c++
#include <iostream>
using namespace std;

class A
{
	public:
		A *operator->(){ return this;}//箭头返回类型必须是 指针
		void mem()
		{
			cout<< "mem in class A!"<< endl;
		}
};

int main(void)
{
	A point;//此时point 不是指针而是是类的对象，对象想调用成员的方法就是 使用运算符重载
	point->mem();
	point.operator->()->mem();//上面的等价写法  ，通过point  显式调用 operator->()函数
	return 0;
}
```

### 函数调用运算符

> 函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别。


#### lambda是函数对象

> lambda表达式的本质是函数对象（通过函数调用运算符实现的）

lambda 表达式的捕获列表可以按值捕获也可以按引用捕获，当按引用的方式捕获的时候，要自己编写相关程序确保捕获的引用存在。


> 什么情况下用lambda 表达式什么情况下用 类？

当内容简单的时候直接用lambda 表达式更方便一点。起始lambda表达式的实现就是转换成类的重载函数。


#### 标准库定义的函数对象

标准库中也是有一些函数可以直接使用的而不必去定义相关的类。

> 适配器bind函数

bind函数定义在头文件functional 中。恶意将bind函数看作一个通用的函数适配器，它接收一个可调用的对象，生成一个新的可调用的对象来“适应”原对象的参数列表。


>一元函数：函数的参数只有一个；
一元断言/一元谓词：函数的参数只有一个，并且返回类型是bool类型。

>二元函数：函数的参数有两个；
二元断言/二元谓词：函数的参数两个，并且返回类型是bool类型。

**占位符**

```c++
void func4(int x1, int x2, int x3, const int& x4, int x5)
{
    cout << "x1 = " << x1 << endl
         << "x2 = " << x2 << endl
         << "x3 = " << x3 << endl
         << "x4 = " << x4 << endl
         << "x5 = " << x5 << endl;
}

void test3()
{
    int number = 10;
    //bind采用的是值传递
    //ref = reference, 引用的包装器
    //cref = const reference, 引用的包装器
    auto f = bind(func4, 1, std::placeholders::_3, std::placeholders::_1, std::cref(number), number);
    number = 30;
    f(50, 40, 60, 70, 90, 80);//没有用到的参数就丢掉
	/*
	x1 = 1 直接传入的参数
	x2 = 60 实参列表第三位
	x3 = 50 实参列表第一位
	x4 = 30 number的引用，后续更改为30
	x5 = 10 传参时number的值
	*/
}


```



> count_if(vec.begin(),vec.end(),bind(greater<int>(),_1,1024));// std::placeholders::_1



> c++标准库函数对象


C++标准库中的函数对象主要包括以下几类：

算法：C++标准库提供了许多算法函数，这些函数可以用于操作容器中的元素。一些算法可以接受函数对象作为参数，以便在算法执行期间调用该函数对象。例如，std::for_each()函数接受一个函数对象，在容器的每个元素上调用该函数对象。
函数适配器：C++标准库提供了一些函数适配器，可以将函数对象或函数指针转换为其他类型的函数对象。例如，std::bind()函数可以将一个函数和几个参数绑定到一个对象上，并返回一个新的可调用对象。
函数生成器：C++标准库提供了一些函数生成器，可以生成符合特定条件的函数对象。例如，std::not_equal_to()函数生成器可以生成一个返回元素不等于给定值的函数对象。
函数比较器：C++标准库提供了一些函数比较器，可以比较两个函数对象的返回值。例如，std::equal_to()函数比较器可以比较两个函数对象的返回值是否相等。
函数组合器：C++标准库提供了一些函数组合器，可以将多个函数对象组合成一个函数对象。例如，std::compose()函数组合器可以将多个函数对象按照从右到左的顺序组合成一个新的函数对象。

这些函数对象可以在C++程序中使用，以实现更灵活和高效的代码。

> c++transform 实现对迭代器中每个元素的修改，前两个参数是迭代器的起始和终止位置，第三个参数是保存的位置


> any_of

> modulus<int>()






#### 可调用对象与function

> 函数的参数个数，和参数类型不同就会构成函数重载

### 重载、类型转换与运算符

> 一个类型转换函数必须是类的成员函数；它不能声明返回值类型，形参列表也必须为空。类型转换函数通常应该是const。

> operator int () 是**类型转换运算符**的重载。

被用于将某种类型的对象转换为int类型。当你希望将一个对象在无需进行复杂计算的情况下直接转换为整数时，**谨慎使用**。  实际中类也是很少提供类型转换运算符。也可以避免将类的类型转换为其他类型：做法是 加上explicit 关键字

> static_cast<int>(si) +3;  显式的强制类型转换

> 通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及两个以上转换源或转换目标是算数类型的转换。


> 一言以蔽之: 除了显式地向bool类型的转换之外，我们应该尽量避免定义类型转换函数并尽可能地限制那些“显然正确”的非显式构造函数。



#### 函数匹配与重载函数的二义性相关问题
```c++
#include <iostream>

using namespace std;

class A
{
	friend int operator+(A &a,int x); //用定义的普通函数实现的，但是为了访问到私有成员n ，需要将其定义为友元函数。

	private:
		int n;

	public:
		A():n(10){}
		operator int() const{return n;}//通过类型转换运算符，调用内置类型转换符
		int operator+(int x){return this->n +x;}//定义一个加法运算符重载运算符
};

int operator+(A &a,int x)
{
	return a.n +x;
}


int main(void)
{
	A a;
//	cout <<a + 20<<endl;  //如果三种方式同时生效此时会报错，编译器不知道该调用哪个 ,

	// 调用下面两句则不会发生重载冲突  。
	cout << a.operator+(20) <<endl;
	cout << operator+(a,20) <<endl;

	return 0;
};

```


